// generated by Gemini/ChatGPT 4.1
// This script checks if a GIF is animated by analyzing its structure
// It fetches the GIF, reads its binary data, and checks for multiple frames or delays
export async function stopAllMotion(isChecked) {
    console.log("stopAllMotion called with isChecked:", isChecked);
    if (isChecked) {
        // If motion is disabled, replace animated GIFs with static versions
        await replaceAnimatedGifs();
    } else {
        // If motion is enabled, remove the static GIFs
        const staticGifs = document.querySelectorAll('img[data-equa11y-static]');
        staticGifs.forEach(img => {
            img.removeAttribute('data-equa11y-static');
            img.src = img.dataset.originalSrc || img.src; // Restore original src
        });
    }

    async function isGifAnimated(gifUrl) {
        try {
            const response = await fetch(gifUrl);
            const arrayBuffer = await response.arrayBuffer();
            const dataView = new DataView(arrayBuffer);

            let frameCount = 0;
            let offset = 6; // Skip GIF signature and logical screen descriptor

            // Loop through blocks to find Image Descriptors or GCEs
            while (offset < dataView.byteLength) {
                const blockIntroducer = dataView.getUint8(offset);

                if (blockIntroducer === 0x2C) { // Image Descriptor
                    frameCount++;
                    // Advance offset past Image Descriptor and associated data
                    offset += 10; // Basic ID size, plus potentially LCT and image data
                } else if (blockIntroducer === 0x21) { // Extension Introducer
                    const extensionLabel = dataView.getUint8(offset + 1);
                    if (extensionLabel === 0xF9) { // Graphics Control Extension
                        // Check for delay time within GCE
                        const delayTime = dataView.getUint16(offset + 4, true); // Little-endian
                        if (delayTime > 0) {
                            return true; // Likely animated due to delay
                        }
                    }
                    // Advance offset past extension block
                    offset += 2; // Skip introducer and label
                    let subBlockSize = dataView.getUint8(offset);
                    while (subBlockSize !== 0x00) { // Data sub-blocks end with 0x00
                        offset += subBlockSize + 1;
                        subBlockSize = dataView.getUint8(offset);
                    }
                    offset++; // Skip the 0x00 terminator
                } else if (blockIntroducer === 0x3B) { // GIF Trailer
                    break; // End of GIF
                } else {
                    offset++;
                }
            }

            return frameCount > 1; // More than one frame suggests animation
        } catch (error) {
            console.error("Error detecting GIF animation:", error);
            return false;
        }
    }

    // Replace animated GIFs with static versions (first frame)
    async function replaceAnimatedGifs() {
        const gifs = document.querySelectorAll('img[src$=".gif"], img[src*=".gif?"]');
        for (const img of gifs) {
            const src = img.src;
            if (await isGifAnimated(src)) {
                // Create a static version using a canvas
                const staticSrc = await getStaticGifFrame(src);
                if (staticSrc) {
                    img.src = staticSrc;
                    img.dataset.originalSrc = src; // Store original src for restoration
                    img.setAttribute('data-equa11y-static', 'true');
                }
            }
        }
    }

    // Helper: Get first frame of GIF as data URL
    async function getStaticGifFrame(gifUrl) {
        return new Promise((resolve) => {
            const img = new window.Image();
            img.crossOrigin = "anonymous";
            img.onload = function () {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL("image/png"));
            };
            img.onerror = function () {
                resolve(null);
            };
            img.src = gifUrl;
        });
    }

}
