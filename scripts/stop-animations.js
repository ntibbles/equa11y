// generated by Gemini/ChatGPT 4.1
// Concise script to stop all motion: GIFs, CSS, and videos
export async function stopAllMotion(isChecked) {
    isChecked ? await replaceAnimatedGifs() : restoreGifs();
    toggleCssMotion(isChecked);
    toggleVideos(isChecked);

    // Replace animated GIFs with static first frame
    async function replaceAnimatedGifs() {
        const gifs = document.querySelectorAll('img[src$=".gif"], img[src*=".gif?"]');
        for (const img of gifs) {
            const src = img.src;
            if (await isGifAnimated(src)) {
                const staticSrc = await getStaticGifFrame(src);
                if (staticSrc) {
                    img.src = staticSrc;
                    img.dataset.originalSrc = src;
                    img.setAttribute('data-equa11y-static', 'true');
                }
            }
        }
    }

    // Restore original GIFs
    function restoreGifs() {
        document.querySelectorAll('img[data-equa11y-static]').forEach(img => {
            img.removeAttribute('data-equa11y-static');
            img.src = img.dataset.originalSrc || img.src;
        });
    }

    // Detect if GIF is animated
    async function isGifAnimated(gifUrl) {
        try {
            const response = await fetch(gifUrl);
            const dataView = new DataView(await response.arrayBuffer());
            let frameCount = 0, offset = 6;
            while (offset < dataView.byteLength) {
                const b = dataView.getUint8(offset);
                if (b === 0x2C) { frameCount++; offset += 10; }
                else if (b === 0x21) {
                    if (dataView.getUint8(offset + 1) === 0xF9 && dataView.getUint16(offset + 4, true) > 0) return true;
                    offset += 2;
                    let size = dataView.getUint8(offset);
                    while (size !== 0x00) { offset += size + 1; size = dataView.getUint8(offset); }
                    offset++;
                } else if (b === 0x3B) break;
                else offset++;
            }
            return frameCount > 1;
        } catch (e) { console.error("Error detecting GIF animation:", e); return false; }
    }

    // Get first frame of GIF as PNG data URL
    function getStaticGifFrame(gifUrl) {
        return new Promise(resolve => {
            const img = new window.Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                const c = document.createElement('canvas');
                c.width = img.width; c.height = img.height;
                c.getContext('2d').drawImage(img, 0, 0);
                resolve(c.toDataURL("image/png"));
            };
            img.onerror = () => resolve(null);
            img.src = gifUrl;
        });
    }

    // Toggle all CSS-based motion (animations, transitions, smooth scrolling)
    function toggleCssMotion(isChecked) {
        const id = 'equa11y-stop-motion';
        let style = document.getElementById(id);
        if (isChecked && !style) {
            style = document.createElement('style');
            style.id = id;
            style.textContent = `
                *, *::before, *::after {
                    animation: none !important;
                    transition: none !important;
                    scroll-behavior: auto !important;
                }
                html { scroll-behavior: auto !important; }
                video, audio {
                    animation: none !important;
                    transition: none !important;
                }
            `;
            document.head.appendChild(style);
        } else if (!isChecked && style) {
            style.remove();
        }
    }

    // Pause or play all videos
    function toggleVideos(isChecked) {
        document.querySelectorAll('video').forEach(video => {
            if (isChecked) video.pause();
            else if (video.paused && !video.ended) video.play().catch(() => {});
        });
    }
}

